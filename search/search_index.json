{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/usage/",
            "text": "Usage\n\n\nThis package ships with a \nzend-config-aggregator provider\n\nthat allows you to use \nModule\n classes as configuration providers in\napplications backed by \nZend\\ConfigAggregator\\ConfigAggregator\n.\n\n\nAs an example, consider the following \nModule\n class:\n\n\nnamespace My\\Zend\\MvcModule;\n\nclass Module \n{\n    public function getConfig()\n    {\n        return [\n            'service_manager' => [\n                'invokables' => [\n                    Service\\MyService::class => Service\\MyService::class, \n                ],\n            ],\n        ];\n    }\n}\n\n\n\nWhen defining configuration for your application, you can use the class\n\nZend\\ConfigAggregatorModuleManager\\ZendModuleProvider\n to wrap the module and\nuse it as a configuration provider:\n\n\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregatorModuleManager\\ZendModuleProvider;\nuse My\\Zend\\MvcModule\\Module as MyZendMvcModule;\n\n$aggregator = new ConfigAggregator([\n    new ZendModuleProvider(new MyZendMvcModule()),\n]);\n\nvar_dump($aggregator->getMergedConfig());\n\n\n\nUsing this provider, the \nModule\n class is being parsed for\n\nzendframework/zend-modulemanager\n interfaces or methods in exactly the same way as\nperformed in zend-mvc applications.\n\n\nThe resultant output of the above example would be:\n\n\narray(1) {\n  'dependencies' => \n  array(1) {\n    'invokables' =>\n    array(1) {\n       'My\\Zend\\MvcModule\\Service\\MyService' =>\n       string(35) \"My\\Zend\\MvcModule\\Service\\MyService\"\n    }\n  }\n}",
            "title": "Usage"
        },
        {
            "location": "/usage/#usage",
            "text": "This package ships with a  zend-config-aggregator provider \nthat allows you to use  Module  classes as configuration providers in\napplications backed by  Zend\\ConfigAggregator\\ConfigAggregator .  As an example, consider the following  Module  class:  namespace My\\Zend\\MvcModule;\n\nclass Module \n{\n    public function getConfig()\n    {\n        return [\n            'service_manager' => [\n                'invokables' => [\n                    Service\\MyService::class => Service\\MyService::class, \n                ],\n            ],\n        ];\n    }\n}  When defining configuration for your application, you can use the class Zend\\ConfigAggregatorModuleManager\\ZendModuleProvider  to wrap the module and\nuse it as a configuration provider:  use Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregatorModuleManager\\ZendModuleProvider;\nuse My\\Zend\\MvcModule\\Module as MyZendMvcModule;\n\n$aggregator = new ConfigAggregator([\n    new ZendModuleProvider(new MyZendMvcModule()),\n]);\n\nvar_dump($aggregator->getMergedConfig());  Using this provider, the  Module  class is being parsed for zendframework/zend-modulemanager  interfaces or methods in exactly the same way as\nperformed in zend-mvc applications.  The resultant output of the above example would be:  array(1) {\n  'dependencies' => \n  array(1) {\n    'invokables' =>\n    array(1) {\n       'My\\Zend\\MvcModule\\Service\\MyService' =>\n       string(35) \"My\\Zend\\MvcModule\\Service\\MyService\"\n    }\n  }\n}",
            "title": "Usage"
        }
    ]
}